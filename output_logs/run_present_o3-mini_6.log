System Prompt:  
You are an HLS Optimization Agent tasked with optimizing a C application accelerated using High-Level Synthesis (HLS). 
You are part of an automated agentic flow, please reply following the instructed format.
Your goal is to find the best combination of function options that minimizes latency while keeping the total area as close as possible to a target value. 
At every iteration you have three options:
1. Synthesize a new configuration to evaluate its latency throughput and area.
If you select this option you should replay in the following format:
"synthesis: <function_name_1> <option_index>, <function_name_2> <option_index>, ..., <function_name_n> <option_index>" for each function in the application.
I will run the synthesis and provide you with the results.
2. See one or more function options.
If you select this option you should reply with the following format:
"inspect: <function_name_1> <option_index>, <function_name_2> <option_index>, ..., <function_name_n> <option_index>"
3. Run the a python script to solve an optimization problem using the google OR-Tools library.
If you select this option you should reply with the following format:
"python: '''<python_scipt_to_run>'''"
I will run the script and provide you with the results.
4. Run gprof on the applacation to profile the code.
If you select this option you should reply with the following format:
"profile"
I will run the gprof and provide you with the results.
5. Accept a solution and provide the final configuration.
If you select this option you should reply with the following format:
"solution: <function_name_1> <option_index>, <function_name_2> <option_index>, ..., <function_name_n> <option_index>"

Only reply with one of the five options following the format provided.

Prompt:  
This is the call graph for the application at hand:
{'copyKey': [], 'copyBlock': [], 'generateRoundKeys80': ['copyKey', 'copyBlock', 'copyKey', 'copyBlock'], 'addRoundKey': [], 'pLayer': ['copyBlock'], 'pLayerInverse': ['copyBlock'], 'present80_encryptBlock': ['generateRoundKeys80', 'addRoundKey', 'pLayer', 'addRoundKey'], 'main': ['present80_encryptBlock', 'printf']}

The application has the following functions with their respective options:
Option for copyKey_hls -  area: 1527.9, latency: 19.0, throughput: 22.0
Option for copyKey_hls -  area: 529.7, latency: 1.0, throughput: 2.0
Option for copyKey_hls -  area: 529.7, latency: 1.0, throughput: 2.0
Option for copyKey_hls -  area: 1527.9, latency: 19.0, throughput: 22.0
Option for copyKey_hls -  area: 2157.7, latency: 21.0, throughput: 24.0
Option for copyBlock_hls -  area: 427.6, latency: 1.0, throughput: 2.0
Option for copyBlock_hls -  area: 1175.3, latency: 15.0, throughput: 18.0
Option for copyBlock_hls -  area: 427.6, latency: 1.0, throughput: 2.0
Option for copyBlock_hls -  area: 427.6, latency: 1.0, throughput: 2.0
Option for copyBlock_hls -  area: 427.6, latency: 1.0, throughput: 2.0
Option for generateRoundKeys80_hls -  area: 2354.3, latency: 596.0, throughput: 599.0
Option for generateRoundKeys80_hls -  area: 2336.0, latency: 596.0, throughput: 599.0
Option for generateRoundKeys80_hls -  area: 1558.8, latency: 286.0, throughput: 289.0
Option for generateRoundKeys80_hls -  area: 1606.3, latency: 575.0, throughput: 580.0
Option for generateRoundKeys80_hls -  area: 1558.8, latency: 286.0, throughput: 289.0
Option for addRoundKey_hls -  area: 126.1, latency: 0.0, throughput: 2.0
Option for addRoundKey_hls -  area: 126.1, latency: 0.0, throughput: 2.0
Option for addRoundKey_hls -  area: 126.1, latency: 0.0, throughput: 2.0
Option for addRoundKey_hls -  area: 126.1, latency: 0.0, throughput: 2.0
Option for addRoundKey_hls -  area: 2152.4, latency: 30.0, throughput: 34.0
Option for pLayer_hls -  area: 1007.7, latency: 150.0, throughput: 154.0
Option for pLayer_hls -  area: 1057.9, latency: 150.0, throughput: 154.0
Option for pLayer_hls -  area: 1007.7, latency: 150.0, throughput: 154.0
Option for pLayer_hls -  area: 1340.7, latency: 87.0, throughput: 90.0
Option for pLayer_hls -  area: 902.8, latency: 79.0, throughput: 82.0
Option for present80_encryptBlock_hls -  area: 13235.1, latency: 3697.0, throughput: 3699.0
Option for present80_encryptBlock_hls -  area: 13235.1, latency: 3697.0, throughput: 3699.0
Option for present80_encryptBlock_hls -  area: 13235.1, latency: 3697.0, throughput: 3699.0
Option for present80_encryptBlock_hls -  area: 13235.1, latency: 3697.0, throughput: 3699.0
Option for present80_encryptBlock_hls -  area: 13235.1, latency: 3697.0, throughput: 3699.0


The synthesizable function names have an extras posfix _hls. Use this name to refer to the function in the optimization process indexing the options starting from 0.
The throughput is expressed in period, the lower the better.

The values reported for a function are obtained synthesizing the function in isolation, selecting the best latency from the child functions.
This means that the child functions are included in the function synthesis. Selecting a different option will affect the final outcome of the parent function.
Different options use different unrolling and pipelining factors. 

The goal is to minimize the latency while keeping the total area as close as possible to 10500.

Provide your first request:

LLM RAW RESPONSE:  ChatCompletion(id='chatcmpl-B7GoUqwgSo3SvcfgEXBTSC7Zs9dZZ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='synthesis: copyKey_hls 1, copyBlock_hls 0, generateRoundKeys80_hls 2, addRoundKey_hls 0, pLayer_hls 4, present80_encryptBlock_hls 0', role='assistant', function_call=None, tool_calls=None, refusal=None))], created=1741072626, model='o3-mini-2025-01-31', object='chat.completion', system_fingerprint='fp_42bfad963b', usage=CompletionUsage(completion_tokens=2940, prompt_tokens=1573, total_tokens=4513, prompt_tokens_details={'cached_tokens': 1536, 'audio_tokens': 0}, completion_tokens_details={'reasoning_tokens': 2880, 'audio_tokens': 0, 'accepted_prediction_tokens': 0, 'rejected_prediction_tokens': 0}), service_tier='default')
synthesis: copyKey_hls 1, copyBlock_hls 0, generateRoundKeys80_hls 2, addRoundKey_hls 0, pLayer_hls 4, present80_encryptBlock_hls 0
func:  copyKey_hls 1
func:   copyBlock_hls 0
func:   generateRoundKeys80_hls 2
func:   addRoundKey_hls 0
func:   pLayer_hls 4
func:   present80_encryptBlock_hls 0
func:  copyKey_hls 1
func:   copyBlock_hls 0
func:   generateRoundKeys80_hls 2
func:   addRoundKey_hls 0
func:   pLayer_hls 4
func:   present80_encryptBlock_hls 0
Last Catapult run:  Catapult_184
  Process                          Real Operation(s) count Latency Throughput Reset Length II Comments 

  -------------------------------- ----------------------- ------- ---------- ------------ -- --------

  /present80_encryptBlock_hls/core                     211    3697       3699            1  0          

  Design Total:                                        211    3697       3699            1  0          

                    Post-Scheduling   Post-DP & FSM Post-Assignment 

  ----------------- --------------- --------------- ---------------

  Total Area Score:  12699.2         13900.7         13235.1        

  Total Reg:          2585.5  (20%)   2451.2  (18%)   2451.2  (19%) 

Prompt:  The synthesis report from last configuration is as follows: 
  Process                          Real Operation(s) count Latency Throughput Reset Length II Comments 

  -------------------------------- ----------------------- ------- ---------- ------------ -- --------

  /present80_encryptBlock_hls/core                     211    3697       3699            1  0          

  Design Total:                                        211    3697       3699            1  0          

                    Post-Scheduling   Post-DP & FSM Post-Assignment 

  ----------------- --------------- --------------- ---------------

  Total Area Score:  12699.2         13900.7         13235.1        

  Total Reg:          2585.5  (20%)   2451.2  (18%)   2451.2  (19%) 
 

LLM RAW RESPONSE:  ChatCompletion(id='chatcmpl-B7GpRy4lw9RIJ0J45G2evgRriIaB0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='synthesis: copyKey_hls 1, copyBlock_hls 0, generateRoundKeys80_hls 2, addRoundKey_hls 0, pLayer_hls 4, present80_encryptBlock_hls 1', role='assistant', function_call=None, tool_calls=None, refusal=None))], created=1741072685, model='o3-mini-2025-01-31', object='chat.completion', system_fingerprint='fp_42bfad963b', usage=CompletionUsage(completion_tokens=5180, prompt_tokens=1802, total_tokens=6982, prompt_tokens_details={'cached_tokens': 1536, 'audio_tokens': 0}, completion_tokens_details={'reasoning_tokens': 5120, 'audio_tokens': 0, 'accepted_prediction_tokens': 0, 'rejected_prediction_tokens': 0}), service_tier='default')
synthesis: copyKey_hls 1, copyBlock_hls 0, generateRoundKeys80_hls 2, addRoundKey_hls 0, pLayer_hls 4, present80_encryptBlock_hls 1
func:  copyKey_hls 1
func:   copyBlock_hls 0
func:   generateRoundKeys80_hls 2
func:   addRoundKey_hls 0
func:   pLayer_hls 4
func:   present80_encryptBlock_hls 1
func:  copyKey_hls 1
func:   copyBlock_hls 0
func:   generateRoundKeys80_hls 2
func:   addRoundKey_hls 0
func:   pLayer_hls 4
func:   present80_encryptBlock_hls 1
Last Catapult run:  Catapult_185
  Process                          Real Operation(s) count Latency Throughput Reset Length II Comments 

  -------------------------------- ----------------------- ------- ---------- ------------ -- --------

  /present80_encryptBlock_hls/core                     211    3697       3699            1  0          

  Design Total:                                        211    3697       3699            1  0          

                    Post-Scheduling   Post-DP & FSM Post-Assignment 

  ----------------- --------------- --------------- ---------------

  Total Area Score:  12699.2         13900.7         13235.1        

  Total Reg:          2585.5  (20%)   2451.2  (18%)   2451.2  (19%) 

Prompt:  The synthesis report from last configuration is as follows: 
  Process                          Real Operation(s) count Latency Throughput Reset Length II Comments 

  -------------------------------- ----------------------- ------- ---------- ------------ -- --------

  /present80_encryptBlock_hls/core                     211    3697       3699            1  0          

  Design Total:                                        211    3697       3699            1  0          

                    Post-Scheduling   Post-DP & FSM Post-Assignment 

  ----------------- --------------- --------------- ---------------

  Total Area Score:  12699.2         13900.7         13235.1        

  Total Reg:          2585.5  (20%)   2451.2  (18%)   2451.2  (19%) 
 

LLM RAW RESPONSE:  ChatCompletion(id='chatcmpl-B7GqZS20ByYgLn4ZghC5Gu4hwVCri', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='python: \'\'\'import itertools\nfrom ortools.sat.python import cp_model\n\n# Define target area value\ntarget_area = 10500\n\n# Data for each function option: list of (area, latency, throughput)\n# Functions and their options in order with indices starting at 0.\nfunctions = {\n    "copyKey_hls": [\n        (1527.9, 19.0, 22.0),\n        (529.7, 1.0, 2.0),\n        (529.7, 1.0, 2.0),\n        (1527.9, 19.0, 22.0),\n        (2157.7, 21.0, 24.0)\n    ],\n    "copyBlock_hls": [\n        (427.6, 1.0, 2.0),\n        (1175.3, 15.0, 18.0),\n        (427.6, 1.0, 2.0),\n        (427.6, 1.0, 2.0),\n        (427.6, 1.0, 2.0)\n    ],\n    "generateRoundKeys80_hls": [\n        (2354.3, 596.0, 599.0),\n        (2336.0, 596.0, 599.0),\n        (1558.8, 286.0, 289.0),\n        (1606.3, 575.0, 580.0),\n        (1558.8, 286.0, 289.0)\n    ],\n    "addRoundKey_hls": [\n        (126.1, 0.0, 2.0),\n        (126.1, 0.0, 2.0),\n        (126.1, 0.0, 2.0),\n        (126.1, 0.0, 2.0),\n        (2152.4, 30.0, 34.0)\n    ],\n    "pLayer_hls": [\n        (1007.7, 150.0, 154.0),\n        (1057.9, 150.0, 154.0),\n        (1007.7, 150.0, 154.0),\n        (1340.7, 87.0, 90.0),\n        (902.8, 79.0, 82.0)\n    ],\n    "present80_encryptBlock_hls": [\n        (13235.1, 3697.0, 3699.0),\n        (13235.1, 3697.0, 3699.0),\n        (13235.1, 3697.0, 3699.0),\n        (13235.1, 3697.0, 3699.0),\n        (13235.1, 3697.0, 3699.0)\n    ]\n}\n\n# The call graph is:\n# generateRoundKeys80_hls calls: copyKey_hls, copyBlock_hls, copyKey_hls, copyBlock_hls\n# pLayer_hls calls: copyBlock_hls\n# present80_encryptBlock_hls calls: generateRoundKeys80_hls, addRoundKey_hls, pLayer_hls, addRoundKey_hls\n#\n# For this simplified optimization, we assume that synthesizing a top-level function (present80_encryptBlock_hls)\n# integrates the selected child options in a way that the overall latency and area equals the parent\'s reported ones.\n# However, if subfunctions are chosen with higher latency, we add a penalty to the overall latency, and similarly for area.\n#\n# We will define a simple cost model:\n#  Total_latency = latency(present80) + max( latency(generateRoundKeys80) + penalty for its children, \n#                                             latency(addRoundKey) (first call),\n#                                             latency(pLayer) + latency(copyBlock) (from its call),\n#                                             latency(addRoundKey) (second call) )\n#\n#  Total_area = area(present80) + area_penalty,\n# where area_penalty is a weighted deviation from target by summing differences in the child contributions.\n#\n# Since the exact synthesis integration is not linear, we use a heuristic: \n# We want to minimize: objective = Total_latency + lambda * abs(Total_area - target_area)\n# \n# For Total_area we use: area(present80) + ( area(generateRoundKeys80) - baseline_GRK ) \n#                                   + ( 2*area(addRoundKey) - baseline_ARK ) \n#                                   + ( area(pLayer) - baseline_PL ) \n# where baselines are chosen from the configuration that gave the reported synthesis.\n#\n# The reported synthesis from our initial run used:\n#  copyKey_hls: option 1 -> 529.7, copyBlock_hls: option 0 -> 427.6\n#  generateRoundKeys80_hls: option 2 -> 1558.8, addRoundKey_hls: option 0 -> 126.1, pLayer_hls: option 4 -> 902.8,\n#  present80_encryptBlock_hls: option 0 -> 13235.1\n#\n# For generateRoundKeys80, its baseline sub-area from children:\n#   It calls copyKey twice and copyBlock twice -> 2*529.7 + 2*427.6 = 1059.4 + 855.2 = 1914.6\n#   But its reported area is 1558.8, so there is some area sharing.\n# We\'ll assume baseline_GRK = 1558.8.\n#\n# For addRoundKey, baseline_ARK = 126.1 (per call).\n# For pLayer, baseline_PL = 902.8.\n#\n# And present80 baseline area = 13235.1.\n#\n# So our estimated total area is approximated as:\n# Total_area = area(present80_encryptBlock_hls) \n#              + ( area(generateRoundKeys80_hls) - 1558.8 )\n#              + ( area(addRoundKey_hls) - 126.1 )*2\n#              + ( area(pLayer_hls) - 902.8 )\n#\n# Similarly, for latency we assume:\n# Total_latency = latency(present80_encryptBlock_hls) \n#                 + max( latency(generateRoundKeys80_hls) - 286.0,     # baseline from option2\n#                        (latency(addRoundKey_hls) - 0.0),             # baseline\n#                        (latency(pLayer_hls) - 79.0) )                # baseline from option4\n#\n# Use lambda to weight area deviation.\nlambda_weight = 0.1\n\n# Prepare lists of options indices for each function\nfn_names = ["copyKey_hls", "copyBlock_hls", "generateRoundKeys80_hls", "addRoundKey_hls", "pLayer_hls", "present80_encryptBlock_hls"]\n\n# Baselines for non-top-level functions based on reported configuration\nbaseline = {\n    "copyKey_hls": 529.7,\n    "copyBlock_hls": 427.6,\n    "generateRoundKeys80_hls": 1558.8,\n    "addRoundKey_hls": 126.1,\n    "pLayer_hls": 902.8,\n    "present80_encryptBlock_hls": 13235.1\n}\nlat_baseline = {\n    "copyKey_hls": 1.0,\n    "copyBlock_hls": 1.0,\n    "generateRoundKeys80_hls": 286.0,\n    "addRoundKey_hls": 0.0,\n    "pLayer_hls": 79.0,\n    "present80_encryptBlock_hls": 3697.0\n}\n\nbest_obj = None\nbest_config = None\n\n# Enumerate all configurations for child functions that influence top-level\nfor ck in range(len(functions["copyKey_hls"])):\n    # Only one instance of copyKey is used in present80? Actually, generateRoundKeys80 calls copyKey twice.\n    # For simplicity, assume both calls use the same configuration.\n    for cb in range(len(functions["copyBlock_hls"])):\n        # copyBlock is used in generateRoundKeys80 twice and in pLayer once.\n        for grk in range(len(functions["generateRoundKeys80_hls"])):\n            for ark in range(len(functions["addRoundKey_hls"])):\n                for pl in range(len(functions["pLayer_hls"])):\n                    for pe in range(len(functions["present80_encryptBlock_hls"])):\n                        # Get synthesized metrics for each selected option\n                        area_pe, lat_pe, _ = functions["present80_encryptBlock_hls"][pe]\n                        area_grk, lat_grk, _ = functions["generateRoundKeys80_hls"][grk]\n                        area_ark, lat_ark, _ = functions["addRoundKey_hls"][ark]\n                        area_pl, lat_pl, _ = functions["pLayer_hls"][pl]\n                        # The child functions copyKey and copyBlock are used within grk and pl\n                        area_ck, lat_ck, _ = functions["copyKey_hls"][ck]\n                        area_cb, lat_cb, _ = functions["copyBlock_hls"][cb]\n\n                        # Compute estimated extra area contributions relative to baseline configuration\n                        extra_area_grk = area_grk - baseline["generateRoundKeys80_hls"]\n                        # For addRoundKey, two calls:\n                        extra_area_ark = (area_ark - baseline["addRoundKey_hls"]) * 2\n                        extra_area_pl = area_pl - baseline["pLayer_hls"]\n                        # We assume that copyKey and copyBlock inside generateRoundKeys80 and pLayer have been optimized \n                        # to baseline values if chosen options equal the baseline.\n                        extra_area_ck = area_ck - baseline["copyKey_hls"]\n                        extra_area_cb = area_cb - baseline["copyBlock_hls"]\n                        # They are called 2 times in generateRoundKeys80 and one time in pLayer\n                        extra_area_inside = 2 * extra_area_ck + 2 * extra_area_cb + extra_area_cb\n\n                        total_area = area_pe + extra_area_grk + extra_area_ark + extra_area_pl + extra_area_inside\n\n                        # For latency: add penalty if the selected child latency is above baseline.\n                        extra_lat_grk = max(0, lat_grk - lat_baseline["generateRoundKeys80_hls"])\n                        extra_lat_ark = max(0, lat_ark - lat_baseline["addRoundKey_hls"])\n                        extra_lat_pl = max(0, lat_pl - lat_baseline["pLayer_hls"])\n                        max_extra_child = max(extra_lat_grk, extra_lat_ark, extra_lat_pl)\n                        total_latency = lat_pe + max_extra_child\n\n                        # Objective: minimize total latency and area difference from target\n                        obj = total_latency + lambda_weight * abs(total_area - target_area)\n\n                        if best_obj is None or obj < best_obj:\n                            best_obj = obj\n                            best_config = {\n                                "copyKey_hls": ck,\n                                "copyBlock_hls": cb,\n                                "generateRoundKeys80_hls": grk,\n                                "addRoundKey_hls": ark,\n                                "pLayer_hls": pl,\n                                "present80_encryptBlock_hls": pe,\n                                "total_area": total_area,\n                                "total_latency": total_latency,\n                                "objective": obj\n                            }\n\n# Print best configuration\nprint("Best configuration:")\nfor fn in fn_names:\n    print(f"{fn}: option {best_config[fn]}")\nprint(f"Estimated total area: {best_config[\'total_area\']}")\nprint(f"Estimated total latency: {best_config[\'total_latency\']}")\nprint(f"Objective: {best_config[\'objective\']}")\n\'\'\'', role='assistant', function_call=None, tool_calls=None, refusal=None))], created=1741072755, model='o3-mini-2025-01-31', object='chat.completion', system_fingerprint='fp_42bfad963b', usage=CompletionUsage(completion_tokens=7670, prompt_tokens=2031, total_tokens=9701, prompt_tokens_details={'cached_tokens': 1920, 'audio_tokens': 0}, completion_tokens_details={'reasoning_tokens': 5120, 'audio_tokens': 0, 'accepted_prediction_tokens': 0, 'rejected_prediction_tokens': 0}), service_tier='default')
python: '''import itertools
from ortools.sat.python import cp_model

# Define target area value
target_area = 10500

# Data for each function option: list of (area, latency, throughput)
# Functions and their options in order with indices starting at 0.
functions = {
    "copyKey_hls": [
        (1527.9, 19.0, 22.0),
        (529.7, 1.0, 2.0),
        (529.7, 1.0, 2.0),
        (1527.9, 19.0, 22.0),
        (2157.7, 21.0, 24.0)
    ],
    "copyBlock_hls": [
        (427.6, 1.0, 2.0),
        (1175.3, 15.0, 18.0),
        (427.6, 1.0, 2.0),
        (427.6, 1.0, 2.0),
        (427.6, 1.0, 2.0)
    ],
    "generateRoundKeys80_hls": [
        (2354.3, 596.0, 599.0),
        (2336.0, 596.0, 599.0),
        (1558.8, 286.0, 289.0),
        (1606.3, 575.0, 580.0),
        (1558.8, 286.0, 289.0)
    ],
    "addRoundKey_hls": [
        (126.1, 0.0, 2.0),
        (126.1, 0.0, 2.0),
        (126.1, 0.0, 2.0),
        (126.1, 0.0, 2.0),
        (2152.4, 30.0, 34.0)
    ],
    "pLayer_hls": [
        (1007.7, 150.0, 154.0),
        (1057.9, 150.0, 154.0),
        (1007.7, 150.0, 154.0),
        (1340.7, 87.0, 90.0),
        (902.8, 79.0, 82.0)
    ],
    "present80_encryptBlock_hls": [
        (13235.1, 3697.0, 3699.0),
        (13235.1, 3697.0, 3699.0),
        (13235.1, 3697.0, 3699.0),
        (13235.1, 3697.0, 3699.0),
        (13235.1, 3697.0, 3699.0)
    ]
}

# The call graph is:
# generateRoundKeys80_hls calls: copyKey_hls, copyBlock_hls, copyKey_hls, copyBlock_hls
# pLayer_hls calls: copyBlock_hls
# present80_encryptBlock_hls calls: generateRoundKeys80_hls, addRoundKey_hls, pLayer_hls, addRoundKey_hls
#
# For this simplified optimization, we assume that synthesizing a top-level function (present80_encryptBlock_hls)
# integrates the selected child options in a way that the overall latency and area equals the parent's reported ones.
# However, if subfunctions are chosen with higher latency, we add a penalty to the overall latency, and similarly for area.
#
# We will define a simple cost model:
#  Total_latency = latency(present80) + max( latency(generateRoundKeys80) + penalty for its children, 
#                                             latency(addRoundKey) (first call),
#                                             latency(pLayer) + latency(copyBlock) (from its call),
#                                             latency(addRoundKey) (second call) )
#
#  Total_area = area(present80) + area_penalty,
# where area_penalty is a weighted deviation from target by summing differences in the child contributions.
#
# Since the exact synthesis integration is not linear, we use a heuristic: 
# We want to minimize: objective = Total_latency + lambda * abs(Total_area - target_area)
# 
# For Total_area we use: area(present80) + ( area(generateRoundKeys80) - baseline_GRK ) 
#                                   + ( 2*area(addRoundKey) - baseline_ARK ) 
#                                   + ( area(pLayer) - baseline_PL ) 
# where baselines are chosen from the configuration that gave the reported synthesis.
#
# The reported synthesis from our initial run used:
#  copyKey_hls: option 1 -> 529.7, copyBlock_hls: option 0 -> 427.6
#  generateRoundKeys80_hls: option 2 -> 1558.8, addRoundKey_hls: option 0 -> 126.1, pLayer_hls: option 4 -> 902.8,
#  present80_encryptBlock_hls: option 0 -> 13235.1
#
# For generateRoundKeys80, its baseline sub-area from children:
#   It calls copyKey twice and copyBlock twice -> 2*529.7 + 2*427.6 = 1059.4 + 855.2 = 1914.6
#   But its reported area is 1558.8, so there is some area sharing.
# We'll assume baseline_GRK = 1558.8.
#
# For addRoundKey, baseline_ARK = 126.1 (per call).
# For pLayer, baseline_PL = 902.8.
#
# And present80 baseline area = 13235.1.
#
# So our estimated total area is approximated as:
# Total_area = area(present80_encryptBlock_hls) 
#              + ( area(generateRoundKeys80_hls) - 1558.8 )
#              + ( area(addRoundKey_hls) - 126.1 )*2
#              + ( area(pLayer_hls) - 902.8 )
#
# Similarly, for latency we assume:
# Total_latency = latency(present80_encryptBlock_hls) 
#                 + max( latency(generateRoundKeys80_hls) - 286.0,     # baseline from option2
#                        (latency(addRoundKey_hls) - 0.0),             # baseline
#                        (latency(pLayer_hls) - 79.0) )                # baseline from option4
#
# Use lambda to weight area deviation.
lambda_weight = 0.1

# Prepare lists of options indices for each function
fn_names = ["copyKey_hls", "copyBlock_hls", "generateRoundKeys80_hls", "addRoundKey_hls", "pLayer_hls", "present80_encryptBlock_hls"]

# Baselines for non-top-level functions based on reported configuration
baseline = {
    "copyKey_hls": 529.7,
    "copyBlock_hls": 427.6,
    "generateRoundKeys80_hls": 1558.8,
    "addRoundKey_hls": 126.1,
    "pLayer_hls": 902.8,
    "present80_encryptBlock_hls": 13235.1
}
lat_baseline = {
    "copyKey_hls": 1.0,
    "copyBlock_hls": 1.0,
    "generateRoundKeys80_hls": 286.0,
    "addRoundKey_hls": 0.0,
    "pLayer_hls": 79.0,
    "present80_encryptBlock_hls": 3697.0
}

best_obj = None
best_config = None

# Enumerate all configurations for child functions that influence top-level
for ck in range(len(functions["copyKey_hls"])):
    # Only one instance of copyKey is used in present80? Actually, generateRoundKeys80 calls copyKey twice.
    # For simplicity, assume both calls use the same configuration.
    for cb in range(len(functions["copyBlock_hls"])):
        # copyBlock is used in generateRoundKeys80 twice and in pLayer once.
        for grk in range(len(functions["generateRoundKeys80_hls"])):
            for ark in range(len(functions["addRoundKey_hls"])):
                for pl in range(len(functions["pLayer_hls"])):
                    for pe in range(len(functions["present80_encryptBlock_hls"])):
                        # Get synthesized metrics for each selected option
                        area_pe, lat_pe, _ = functions["present80_encryptBlock_hls"][pe]
                        area_grk, lat_grk, _ = functions["generateRoundKeys80_hls"][grk]
                        area_ark, lat_ark, _ = functions["addRoundKey_hls"][ark]
                        area_pl, lat_pl, _ = functions["pLayer_hls"][pl]
                        # The child functions copyKey and copyBlock are used within grk and pl
                        area_ck, lat_ck, _ = functions["copyKey_hls"][ck]
                        area_cb, lat_cb, _ = functions["copyBlock_hls"][cb]

                        # Compute estimated extra area contributions relative to baseline configuration
                        extra_area_grk = area_grk - baseline["generateRoundKeys80_hls"]
                        # For addRoundKey, two calls:
                        extra_area_ark = (area_ark - baseline["addRoundKey_hls"]) * 2
                        extra_area_pl = area_pl - baseline["pLayer_hls"]
                        # We assume that copyKey and copyBlock inside generateRoundKeys80 and pLayer have been optimized 
                        # to baseline values if chosen options equal the baseline.
                        extra_area_ck = area_ck - baseline["copyKey_hls"]
                        extra_area_cb = area_cb - baseline["copyBlock_hls"]
                        # They are called 2 times in generateRoundKeys80 and one time in pLayer
                        extra_area_inside = 2 * extra_area_ck + 2 * extra_area_cb + extra_area_cb

                        total_area = area_pe + extra_area_grk + extra_area_ark + extra_area_pl + extra_area_inside

                        # For latency: add penalty if the selected child latency is above baseline.
                        extra_lat_grk = max(0, lat_grk - lat_baseline["generateRoundKeys80_hls"])
                        extra_lat_ark = max(0, lat_ark - lat_baseline["addRoundKey_hls"])
                        extra_lat_pl = max(0, lat_pl - lat_baseline["pLayer_hls"])
                        max_extra_child = max(extra_lat_grk, extra_lat_ark, extra_lat_pl)
                        total_latency = lat_pe + max_extra_child

                        # Objective: minimize total latency and area difference from target
                        obj = total_latency + lambda_weight * abs(total_area - target_area)

                        if best_obj is None or obj < best_obj:
                            best_obj = obj
                            best_config = {
                                "copyKey_hls": ck,
                                "copyBlock_hls": cb,
                                "generateRoundKeys80_hls": grk,
                                "addRoundKey_hls": ark,
                                "pLayer_hls": pl,
                                "present80_encryptBlock_hls": pe,
                                "total_area": total_area,
                                "total_latency": total_latency,
                                "objective": obj
                            }

# Print best configuration
print("Best configuration:")
for fn in fn_names:
    print(f"{fn}: option {best_config[fn]}")
print(f"Estimated total area: {best_config['total_area']}")
print(f"Estimated total latency: {best_config['total_latency']}")
print(f"Objective: {best_config['objective']}")
'''
Prompt:  The output of the script is: 
Best configuration:
copyKey_hls: option 1
copyBlock_hls: option 0
generateRoundKeys80_hls: option 2
addRoundKey_hls: option 0
pLayer_hls: option 4
present80_encryptBlock_hls: option 0
Estimated total area: 13235.1
Estimated total latency: 3697.0
Objective: 3970.51

LLM RAW RESPONSE:  ChatCompletion(id='chatcmpl-B7GrNqE4oLAktlWM7fjFnsVaQ1oZx', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='solution: copyKey_hls 1, copyBlock_hls 0, generateRoundKeys80_hls 2, addRoundKey_hls 0, pLayer_hls 4, present80_encryptBlock_hls 0', role='assistant', function_call=None, tool_calls=None, refusal=None))], created=1741072805, model='o3-mini-2025-01-31', object='chat.completion', system_fingerprint='fp_42bfad963b', usage=CompletionUsage(completion_tokens=1916, prompt_tokens=4676, total_tokens=6592, prompt_tokens_details={'cached_tokens': 2048, 'audio_tokens': 0}, completion_tokens_details={'reasoning_tokens': 1856, 'audio_tokens': 0, 'accepted_prediction_tokens': 0, 'rejected_prediction_tokens': 0}), service_tier='default')
solution: copyKey_hls 1, copyBlock_hls 0, generateRoundKeys80_hls 2, addRoundKey_hls 0, pLayer_hls 4, present80_encryptBlock_hls 0
DONE!
Logging results in  outputs_present80_encryptBlock_o3-mini_6/present80_encryptBlock.log

